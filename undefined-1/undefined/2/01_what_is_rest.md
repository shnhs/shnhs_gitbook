# REST API란?

## F/E 와 B/E

우리가 커다란 시스템을 만들 때 보통 Tier 혹은 Layer로 구분하곤 한다.

- Tier : 물리적 구분
- Layer : 논리적 구분

프로그램을 몇 개의 Tier 혹은 Layer로 구분한다면  
사용자에게 가까운 부분, 예를들면 UI 같은 부분을 Front-End; FE,  
사용자에게 먼 부분, 예를들면 서버 같은 부분을 Back-End; BE 라고 보통 부른다.

FE와 BE로 나누어 진다고 해도 두 부분 사이의 소통,  
즉 데이터 통신이 이루어져야 사용자가 사용가능한 프로그램일 것이다.

일반적으로 웹브라우저에서 javascript로 동작하는 프로그램 개발을 FE.  
Tomcat과 같이 WAS(웹 애플리케이션 서버)에서 동작하는 프로그램 개발을 BE 라고 한다.  
(지금 내가 배우고 일하는) BE에서 사용하는 대표적인 프로그램은 Java Servlet, Spring Boot등이 있다.

FE 와 BE은 보통 http를 사용하여 통신한다.  
정확히는 http이라는 프로토콜(약속) 아래 여러 웹 기술을 활용하여 통신한다.

동시에 REST API라는 것을 사용한다.  
일종의 아키텍처 스타일을 사용하는 셈이다.

> 아키텍처 vs 아키텍처 스타일
>
> - 아키텍처란 무언가를 설계하고 구축하는데 사용하는 패턴과 기술을 말한다.
>
> - 아키텍처 스타일이란 특정한 특성을 공유하는 아키텍처의 집합,  
>   어떤 아키텍처에 적용되는 제약조건의 집합 이라고 할 수 있다.

REST API 이외에도 SOAP, GraphQ와 같은 웹 기술, 프로토콜을 사용할 수 있다.

> TODO  
> SOAP 와 REST의 차이  
> WAS란 무엇인가  
> Java Servlet

## API란?

REST API 중 먼저 API를 알아보자.

약자를 풀어쓰면 Application Programming Interface  
약어로 풀어도 너무 추상적이라 헷갈린다.(물론 나도 그렇다)  
API란 정의 혹은 프로토콜 집합으로 두 프로그램이 서로 통신 할 수있게 하는 메커니즘이라고 한다.  
더 쉽게 말하면 컴퓨터 혹은 컴퓨터 프로그램 사이의 연결이다.  
따로 겉으로 드러나는것은 없다. 하지만 내부적으로 이렇게 처리를 하겠다 라고 정한 약속, 정의 같은 개념을 의미한다.

API를 풀어쓴 단어중 가장 와닿지 않는 단어가 바로 인터페이스 일 것이다.  
블로그에서 마음에 와닿는 비유를 보아서 나도 같은 비유를 옮겨와 보겠다.

    인터페이스는 자동차 브레이크다. 여러 특징을 꼽을 수 있겠지만 일단 크게 2개만 꼽자면
    사용이 편리하다. 그리고 내부에 무슨일이 일어나는지는 모른다. 라는 점이다.
    운전자는 브레이크만 밟음으면 손쉽게 자동차의 속도를 줄일 수 있다.
    그리고 그 과정에서 운전자는 브레이크 내부의 원리는 전혀 몰라도 사용할 수 있다.

    인터페이스는 구현과 사용을 분리하고 그 내부 정보를 은닉하고 추상화 함으로써
    사용자가 어떤 기능이나 기술을 사용하기 쉽게 만들어준다.

> 정보은닉 vs 캡슐화
>
> - Information Hiding(Principle) - 정보은닉  
>   내부에서 어떤 일이 일어나는지 밖으로 보이지 않는다. 라는 개념이다.
> - Encapsulation(Technique) - 캡슐화
>   정보 은닉을 구현하기 위한 기술적 개념이다.  
>   정보를 하나로 묶어 어느 한 공간?에 두고 그 공간을 통하는 인터페이스를 통해서만 통신한다.

## REST(Representational State Transfer)란 무엇인가

어떤 기능에 대한 인터페이스를 어떻게 정의할거냐  
그리고 어떤 방법으로 구현할것인가 하는 방법은 아주 많고 다양할 수 있다.  
그러나 모두 각자의 방식으로 구현하면 통일성도 서로 통신하기 힘들 것이다.  
다 같이 어떤 원칙을 따라가면 서로 편할 것이고, 그에 대한 약속으로 정한 것이 바로 REST이다.

약자를 직역하면 “표현 상태 전송” 이라고 한다.

> REST는 로이 필딩의 논문에서 박사학위 논문에서 최초로 소개된 아키텍처 스타일이다.  
> REST는 "Uniform Connector 인터페이스"라는 제약조건과 함께,  
> 몇몇 네트워크 기반 아키텍처 스타일의 혼합으로 이루어진 하이브리드 스타일이다.

### REST 제약조건(특징)

위에서 REST는 몇가지 제약조건이 있다고 언급했다.  
보통 REST 하려면 7가지의 제약조건을 만족해야 한다고 정리된다.

1. Starting With the Null Style  
   설계자는 어떤 시스템을 설계할 때 제약조건이 없는 상태에서 점진적으로 제약조건을 추가해야 한다.  
   추가한 제약조건들은 시스템내에서 서로 조화롭게 동작해야 한다.
2. Client - Server  
   그 다음 제약조건은 클라이언트 - 서버 스타일 도입이다.  
   이 제약조건의 원칙은 관심사의 분리이다.  
   데이터 저장과 UI에 대한 관심사를 서로 분리하여  
   클라이언트는 UI에 대한 이식성을 개선하고, 서버 측면에서는 구성요소를 단순화 하여 확장성을 개선한다.
   이 처럼 관심사를 분리하여 각 요소가 독립적으로 개선될 수 있도록 만들어준다.
3. Stateless  
   HTTP는 기본적으로 무상태성이다. REST는 HTTP를 기반으로 하기 때문에 똑같이 무상태성이다.  
   무상태성이라는 뜻을 다시 한번 상기하면 클라이언트의 상태를 서버에 저장하지 않는다 라는 의미이다.  
   따라서 서버는 클라이언트의 요청을 모두 별개의 요청으로 인식하여 처리한다.  
   따라서 클라이언트가 서버에 보내는 요청에는 해당 요청을 이해하고 처리하는데 필요한 모든 모든 정보가 포함되어야 한다.  
   이 제약조건으로 가시성, 신뢰성, 확장성을 유도한다.
   - 가시성: 요청에 대한 특징을 위해 요청 외의 다른 부분은 고려하지 않아도 된다.
   - 신뢰성: 부분적인 장애 복구를 위해 고려할 것이 많지 않다. 이때문에 복구가 용이하여 신뢰도가 올라간다.
   - 확장성: 서버측에 클라이언트 관련 정보를 저장하지 않아 리소스를 확보 할 수 있고, 구현이 쉽다.  
     이는 곧 확장성의 향상으로 이어진다.
4. Cache  
   캐시 제약조건을 추가하여 응답데이터가 cache에 저장되어있는지 아닌지 암시적 혹은 명시적으로 지정해야 한다.  
   만약 응답이 cacheable 하면 동일한 요청에 동일한 응답을 사용할 수 있는 권한이 주어진다.  
   캐시 제약조건을 통해 서버-클라이언트 통신의 통신을 부분적으로 제거하여 지연시간을 감소하고  
   서버 리소스를 효율적으로 사용할 수 있다.
5. Uniform Interface (핵심)  
   REST의 핵심적인 특징이 바로 컴포넌트들 간의 Uniform interface를 사용한다는 점이다.  
   컴포넌트란 웹을 이루는 요소들 예를들어 client, server, cache, resolver, tunnel 등을 말한다.  
   웹에도 일반적인 소프트웨어 공학 원칙을 적용한 개념이다.

   이는 거의 규칙처럼 다루어지는 부분이기 때문에 오히려 비효율적일 수 도 있다.  
   어떤 어플리케이션에서 필요한 형태가 아닌 표준화된 형태로 변환하여 사용해야 하기 때문이다.

   uniform interface를 위한 제약조건 4가지를 필딩 제약조건 이라고도 한다.

   - Identification of Resources
   - Manipulation of Resources through Representaion
   - Self-descriptive Messages
   - Hypermedia as the Engine of Application State

6. Layered System  
   REST는 여러개 레이어, 계층으로 구성된다. 그러나 클라이언트는 REST API 서버만 호출한다.  
   API서버는 순수하게 비즈니스 로직만 수행하고 그 앞단에 보안, 로드밸런싱, 인증을 추가하여  
   구조의 유연함을 확보 할 수 있다.  
   또한 계층 구조를 통해 레거시 서비스를 캡슐화 한다.
7. Code on Demand  
   서버로부터 스크립트를 받아서 클라이언트에서 수행한다.  
   이는 클라이언트 에서 사전에 구현해야할 기능을 감소시켜 기능을 단순화 할 수 있다.  
   이 조건은 REST의 선택적인 제약조건이다.

REST는 API를 위해 만들어진 아키텍쳐는 아니다. 웹에서의 일반적 사용에 특화된 아키텍쳐이다.  
그러나 API를 만들 때 사용하면 유용하기 때문에 보통 따르는 것이다.

## 필딩 제약조건

보통 RESTful 한가를 많이 판가름 하는것이 필딩 제약조건이기 때문에 더 자세히 풀어서 보자

### Identification of Resources

URI를 사용하여 리소스를 식별한다 라는 개념으로, 개별 자원에 대해 식별 가능해야 한다 라는 조건이다.

### Manipulation of Resources through Representations

표현 혹은 메세지를 통해 리소스를 조작한다 라는 조건이다.  
클라이언트 요청에 어떤 자원에 대한 적절한 표현과 작업을 위한 메타데이터가 있다면  
서버는 이를 활용하여 서버상에서 해당 자원을 변경하거나 어떤 작업을 할 수 있다.

### Self-descriptive Messages

자기서술적 메시지를 사용해야 한다는 제약이다.  
자기서술적 메세지란 어떤 요청 혹은 응답이 자신을 어떻게 처리해야하는지 충분한 정보를 포함해야 한다는 의미이다.

```java
GET / HTTP 1.1 // 목적지가 없어 어디에서 처리해야하는지 정보가 없다.
==============
GET / HTTP 1.1
Host: localhost:8080 // 목적지와 메서드가 있어 어디서 어떻게 처리해야 할 지 알수있다.
```

```java
HTTP/1.1 200 OK

{ name: kim } // 프로그램은 해당 데이터가 어떤 형식의 응답인지 알 수 없다.
==============
HTTP/1.1 200 OK
Conent-Type: application/json // 해당 응답 데이터가 어떤 형식인지 알려줘야 한다.

{ name: kim }
```

> 프로그램 입장에서 json 같은 형식의 데이터를 주면  
> 그냥 key는 key고 value는 value다. 각 데이터에 대한 의미를 추론하지 못한다.  
> 따라서 프로그램은 그 데이터의 의미를 해석하기 어려워 자기서술적이지 못하다.  
> MIME 타입으로 설명하면 application/json 이 아니라 application/dns + json 으로 써야한다.
> 전자를 보통 많이 쓰지만, 자기서술적 메세지의 의미에는 후자의 경우가 더 부합한다.

### Hypermedia as the Engine of Application State

가장 많이 안 지켜지고 까다로운 제약조건이다.

웹 브라우저는 보통 어떤 상태를 표현하고 있는 중이다 라고 말할 수 있다.  
예를 들면 문서를 보다가 링크 등을 클릭하면 다음 페이지로 넘어가는데,  
이를 다르게 말하면 1번 페이지 상태에서 2번 페이지 상태로 전환 된 것이다.

이렇게 하려면 표현에 선택 가능한 상태전환이 포함되어야 한다.  
즉 하이퍼 링크를 통해 상태를 변경해야 한다. 즉 페이지를 이동해야 한다.

그러나 보통 표현에 링크를 넣는것이 아닌 API 문서를 사용하여 처리한다.  
(표현에서 상태 전환을 선택하는 것이 아니라. API 문서를 참조하여 상태전환을 강제한다…?? - 좀 더 생각해봐야할 듯)

> 리처드슨 성숙도 모델  
> Level.0 The Swamp of Pox  
> Level.1 Resource  
> Level.2 HTTP verbs  
> Level.3 HyperMedia Control  
> 보통 업계에서는 Level.2 만 되도 REST 라고 한다.

## 리소스 vs 표현

REST에서는 리소스, 표현, 실제 데이터는 모두 구분되는 개념이다.

리소스란 추상이다. 모든 시간에 통용되는 엔티티의 집합이다.  
시간이 지나도 내부 속성이나 값은 바뀔 수 있어도 본질적인 구분은 바뀌지 않는다? 라는 의미라고 정리하고자 한다.  
리소스는 서버에 저장된 무언가가 아니다. 저장된 파일 같은 것이 아니다.

표현이란 Data + Metadata + Meta-metadata … 로 표현되는,  
사실상 http 메시지 이다.
리소스에 어떤 조작을 가할 것인지 http method로 표현하고,  
어떤 내용의 조작을 가할지는 http content-type, body로 표현한다.

참고자료  
<https://www.redhat.com/ko/topics/cloud-native-apps/what-is-an-application-architecture>  
<https://learn.microsoft.com/ko-kr/azure/architecture/guide/architecture-styles/>  
<https://m.blog.naver.com/aservmz/222241342922>  
<https://yozm.wishket.com/magazine/detail/727/>  
<https://rutgo-letsgo.tistory.com/158>  
<https://sabarada.tistory.com/9>
