# Layered Architecture

## 관심사의 분리 (SoC; Separation of Concerns)

레이어드 아키텍쳐 의 중심 개념, SW의 핵심 원칙이다.\
'프로그램을 작은 부분들로 분리하고, 각 부분은 각각의 관심사에 대해서만 처리를 한다.' 라는 개념이다.

### 관심사란?

간단히 정리해서 코드에 영향을 주는 특정한 정보의 집합이다.\
프로그램에서 구현하는 하나하나의 기능들을 관심사라고 부르면 될 것 같다.

### 관심사 분리가 필요한 이유

강의를 들으며 느낀 점은 너무나 당연하게 이렇게 해야할 수 밖에 없는 것 처럼 느껴졌다.

커다란 프로그램은 만들기도 힘들고 유지보수도 힘들것이다.\
내용이 많아지면 사람이 전부 기억하고 관리하는 것이 힘든게 당연하다.\
따라서 종류 혹은 기능에 따라 적절한 그룹으로 나누어 관리하자 라는것은\
일상생활에서 우리도 당연하게 생각하는 자연스러운 개념인 것 같다.

마치 폴더를 관리하는 것과 유사하다.\
우리가 파일 시스템의 폴더를 만들어 사진, 동영상, 문서 를 나누어 관리하듯이\
코드도 종류나 기능에 따라 한데 묶어서 관리하는 것이 개발과 이후에 유지보수에도 도움이 될 것이다.\
Java에서 패키지가 이를 위해 존재한다.

### 관심사 분리의 장단점

그러나 세상에 모든 것이 그렇듯 마냥 장점만 있는것은 아니다.

A 관심사와 B관심사를 분리한다고 가정하자,\
편의상 A기능 개발, B기능 개발을 한다고 생각한다.

1. A와 B를 분리 했으므로 A기능을 만들 때 B기능에 대한 고려 없이 기능을 개발하면 된다는 장점이 있다.
2. 그러나 A기능을 만들면서 B기능에 영향을 줄 수 있는 부분이 있을 수 있는데 오히려 이를 고려하지 못 할 수도 있다.

1에 관한 개념이 응집도, 2에 대한 개념에 결합도 가 있다.\
둘은 대체로 반비례한다.

### 응집도

용어에서 느껴지는 그대로, 어떤 두 코드?기능?(자료에서는 모듈이라고 표현)이 서로 얼마나 응집되어 있는가를 나타낸다.\
즉 두 기능이 서로 얼마나 연관되어 있는가 라는 개념이다.\
관심사를 깔끔하게 분리하면 좋겠지만, 언제나 항상 가능한것은 아닐 것이기에 두 관심사가 어느정도 관련이 있는지(얼마나 독립적인 기능으로 구성되었는지)를 의미한다.

### 결합도

응집도와 반대로 두 관심사가 서로 얼마나 연관되어 있는지에 대한 개념이다. 결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다.

## Layered Architecture

SW 개발을 할 때 주로 사용하는 레이어드 아키텍쳐 ‘스타일’이다.\
여러개의 수평 계층으로 구성된 아키텍쳐 패턴이다.\
각 계층은 구성 요소 또는 코드를 논리적으로 구분한 단위 이다.

보통 접하는 프로그램을 생각하면 보통 '웹'과 '기능'으로 분리 할 수 있다.\
기능은 그 프로그램을 사용하는 본질적인 사용목적,\
웹은 기능을 쉽게 사용할 수 있도록 표면적으로 보이는 것 이라고 할 수 있다.

프로그래밍에서 자주 쓰는 용어로 바꿔 말하면\
기능을 Business Logic 혹은 도메인, 웹은 UI라고 부르는 경우가 많다.

즉 웹과 기능을 나누는것은 Business Logic과 UI를 분리하는 것이다.

웹은 계층으로 말하면 UI Layer에서 다루고, 코드상에서는 Spring Web Controller 로 구현된다.\
기능(Business Logic)은 그 아래 Layer에서 다룬다. 코드상에서는 Service 로 구현된다.

## 4-Tier Layered Architecture

일반적으로 많이 사용하는 4계층 아키텍쳐이다.\
일반적으로 아래와 같은 계층으로 구성된다.

```
Presentation Layer / Business Layer / Persistance Layer / DB Layer
```

### Presentation Layer

UI Layer라고도 부르는 것 같다.\
사용자가 어떤 데이터나 기능을 요청하기 위한 화면을 표시하는 것을 주 관심사로 한다.\
위에서 언급한 것 처럼 Controller 형태로 구현된다.

### Business Layer

Business Logic 즉 기능을 수행하는 것을 주 관심사로 한다.\
UI Layer를 통해 전달받은 데이터를 기능에 따라 처리하여 응답한다.\
대표적으로 Service 혹은 Domain Model 등의 형태로 구현된다.

### Persistance Layer

DB에 대한 접근 및 처리를 주 관심사로 한다.\
Business Layer가 어떤 데이터를 필요로 할 때 DB를 직접 접근하는 것이 아니라\
Persistance Layer를 통해서 데이터를 다루게 된다.\
Repository, DAO 등의 형태로 구현된다.

> 이름부터 영속성 계층이다.\
> 영속성 이라는 개념에 대해 더 공부해야 할 듯 하다.

### DB Layer

실제로 사용하는 Database가 위치하는 게층이다.



## 식별자 전략

식별자란 어떤 대상을 유일하게 구분할 수 있는 이름같은 것을 의미한다.\
예를 들어 상품의 고유번호나 일련번호, 회원 아이디 같은 것이 될 수 있다.

### UUID; Universally Unique Identifier

식별자 전략 중 하나로 가장 보편적인 방법 중 하나이다.

총 32개의 문자와 4개의 하이픈(-)으로 이루어져있으며 8-4-4-4-12 의 형태를 가진다.\
하이픈을 제외한 각 문자는 32개의 16진수로 표현된다.\
해당 포맷의 UUID는 총 340,282,366,920,938,463,463,374,607,431,768,211,456개의 사용가능한 식별자를 가질 수 있다.

UUID의 단점이라고 하면 시간의 순서로 정렬할 수 없다는 것이다.\
UUID를 생성할 떄 시간 정보가 아예 반영이 안되는 것은 아니지만,\
생성된 UUID를 기준으로 사람이 보통 생각하는 오름/내림 차순으로 정렬할 때\
시간 순서대로 정렬되지는 않는다는 단점이 있다.

> 이론상 문자열 갯수와 각 문자열이 한정된 범위를 가지기 때문에 UUID는 유한한 값이다.\
> 그러나 임의로 생성하는 UUID가 충돌할 확률은 아주아주 극 희박한 확률이기 때문에 크게 신경 쓸 부분은 아니라고 한다.\
> 혹여나 염려되는 상황에는 UUID + 다른 고유 문자열을 섞어쓰는 형태도 있다고 한다.

### ULID, TSID

UUID가 시간순서로 정렬이 불가한 단점을 고친 식별자 전략이다.\
생성할 때 시간의 정보를 반영할 수 있다.

## 리팩토링

위에서 언급한 대로 우리는 프로그램을 만들때 관심사의 분리에 따라 코드를 분리한다.\
분리된 코드를 어떻게 나누어 배치하느냐를 `설계`를 한다 라고 한다.

그리고 프로그램의 설계 방식을 개선하는 것을 `리팩토링`이라고 한다.\
순수한 리팩토링은 기능은 바뀌지 않고 설계만 바꾸는 것이다.
