# 3. Collection Pattern

실제로 API 설계할 때 REST 제약조건 보다도 RESTful 한지 아닌지 볼 수 있는 부분이다. 잘 익혀두자.

대부분의 경우 여러개의 리소스를 그룹으로 묶을 수 있다.  
폴더 처럼 여러개의 리소스를 컬렉션(그룹)으로 묶는다.  
그리고 리소스는 리소스의 이름으로 참조되고 메서드 집합으로 작업된다.

예를들어 게시글 시스템을 생각해보자

먼저 게시글 목록이 있어야 한다. 게시글 컬렉션을 /posts 의 형태의 리소스를 가진다.  
일반적으로 컬렉션은 복수형을 사용한다.  
그리고 개별 게시글을 식별하기 위해 /posts/{post_id}와 같은 리소스를 가질 수 있다.  
여기서 주의할점은 post_id는 해당 리소스의 ID가 아니다.  
Resource ID = URL 혹은 URI이고, post_id는 URI를 구성하는 요소 중 하나, posts 컬렉션 내 식별자이다.

> 보통 컬렉션(그룹)은 복수형으로 사용하는것이 보편적이다.  
> 무조건적인 법칙은 아니지만 컬렉션 패턴에서 이렇게 쓰는게 일반적이다. 지키자

게시글는 하위에 댓글이라는 컬렉션을 가질 수 있다.  
이를 패턴으로 표현하면 posts/{post_id}/comments 형태로 표현 할 수 있다.  
혹은 comments?post_id={post_id} 처럼 서치 쿼리를 통해 표현 할 수도 있다.

> 사실 의미가 미묘하게 다르다.  
> posts/1/comments -> 1번 게시글의 댓글 컬렉션  
> comments?post_id=1 -> 댓글 중 게시글 아이디가 1번인 댓글 필터링  
> 구현하는 코드와 결과는 사실상 동일하긴 하다.

/user/{post_id}/comments/{id} 와 같이 댓글의 id를 붙여 관리할 수도 있다.

게시글을 수정하는 페이지를 표현하고자 하면 /posts/{post_id}/edit 와 같이  
post_id의 게시글을 수정하는 페이지 리소스 라는 표현으로 나타낼 수 있다.  
물론 위에서 표현한것처럼 edit?post_id={post_id} 라는 형태로 구성할 수도 있다.

다만 만약에 /comments/{id}/edit 이라는 기능을 도입할 경우  
edit?comments={comments_id} 와 같은 패턴으로 들어올수 있어,  
edit/ 뒤가 post_id인지 comments_id 인지 구분하는 로직을 구성해야 해서 복잡할 수 있다.

(REST API는 단순히 페이지만 표현할 일은 거의 없다. 이런 표현은 FE에 맡기고 BE에서는 제약해도 무방???)

그룹이 아닌 경우라면 단수형으로 표현해도 무방  
예를 들면 세션이 있다. /session  
세션은 하나만 유지하고, 다른 세션을 참고할 일도 없기 때문에 유일하게 관리되므로 단수형으로 표현하여 식별 할 수 있다.

> 만약 편집페이지의 유형을 구분하여 사용하고 싶다는 등의 필요성이 있다면  
> 괜히 edit?edit_type={blahblah}와 같은 형태보다  
> page 라는 리소스를 새로 생성하여 /pages/edit-posts, /pages/edit-comments 와 같이 구성 하는것이 더 깔끔
