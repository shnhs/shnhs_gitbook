# 애플리케이션 수준의 보안

## 인증 (Authentication)

> 컴퓨터에 보안에서의 인증은 로그인 요청 등을 통해 통신상에서 보내는 사람의  
> 디지털 정체성을 확인하는 시도의 과정이다. - 위키백과

정말정말 쉽게 얘기하면 로그인 과정을 인증이라고 할 수 있다.  
우리가 로그인을 하는 이유는 컴퓨터가 ‘너는 누구니?’ 라고 묻는 질문에 나의 ID와 Password로 대답하는 것이다.

인증에 대한 정의를 다르게 표현한 내용중에 아래와 같은 내용이 있다.

> 인증이란 어떤 정보가 어떤 사람에게 유일하게 속한다는 사실을 확인하고  
> 이를 증명하는 행위를 뜻한다.

여기서 어떤 정보라는 것은 우리가 인증을 할 때 필요한 내용, 인증을 위해 제공하는 정보가 된다.

인증을 위한 정보, 즉 인증 수단은 크게 3가지 범주로 분류할 수 있다.

1. 지식  
   가장 흔히 접할 수 있는 ID와 Password를 통한 로그인 과정에서 Password가 일종의 지식이다.  
   내가 제시한 ID에 대응되는 Password가 무엇인지 아는것을 증명함으로 써 내가 그 ID의 소유자이고,  
   그 소유자가 바로 나 임을 증명할 수 있다.  
   Password 외에도 핸드폰 등에서 많이 사용하는 패턴, 그리고 비밀번호 변경등의 과정에서 가끔 볼 수 있는  
   질문-답변 쌍도 지식의 범주에 들어갈 수 있다.

2. 소유  
   내가 가진 무언가를 통해 나를 증명하는 방법이다. OTP나 보안 인증서, 보안 카드 등이 여기에 포함 될 수 있다.  
   OTP 같은 경우 어떤 소유자의 OTP 기기로 코드를 보내고 그 코드를 내가 인증함으로써 내가 그 사람이다 라는 것을 증명 할 수 있다.  
   소유물로 인증하는 방법은 소유물에 대한 도난 혹은 분실에 대한 위험이 있긴 하지만,  
   보안성이 좋기 때문에 2차 인증 수단으로 많이 활용된다.

3. 신체  
   나의 신체적 정보를 통해 나를 인증하는 방법이다. 요즘 핸드폰에서 많이 사용하는 지문, 얼굴 인식,  
   그리고 공항등에서 가끔 볼 수 있는 홍채, 정맥 인식 등이 여기에 해당된다.  
   나의 신체의 일부 이기에 보안성도 좋고, 분실의 위험이 거의 없으나, 상대가 가진 내 신체 인증 정보가 없어지면  
   이후에 다시 인증할 방법이 없다는 단점이 있다.

> 한줄로 정리하면 인증은 Identification(신원확인)에 관한 내용.  
> “나는 누구이다”를 증명하는 과정이다.

## 인가 (Authorization)

사실 인가 라는 단어보다, 허가라는 단어로 보면 좀 더 쉽게 마음에 와닿을 것이다.  
좀 더 풀어서 얘기하면 권한 확인을 하는 과정이라고 볼 수 있다.  
인증 과정을 통해 누구인지는 알겠는데, 그래서 지금 요청한것에 대한 권한이 있는지를 확인하는 개념이다.  
보통은 인증과 인가를 따로 처리하지 않고 같이 처리한다.

### 다양한 입장에서의 인증, 인가

1. 사용자 입장  
   그냥 로그인 과정(인증 절차)를 거치고 난 후  
   어떤 요청에 대한 거부를 확인하지 않는 이상 인가 과정에 대한 존재를 느끼기 어렵다.  
   왜냐하면 위에서도 언급했듯 보통 인증과 인가 처리를 같이 하기 때문에  
   권한이 없는 요청을 할 수 있는 루트를 사전에 막아 놓기 때문이다.  
   일반 사용자로 로그인 했는데, 굳이 관리자 페이지로 가는 버튼을 보여주지 않는다 를 생각하면 이해가 될 것이다.

2. 클라이언트 입장
   로그인 과정을 통해 서버로부터 토큰 혹은 세션 아이디를 받아온다.  
   로그인 이후에는 매 요청마다 받아온 무언가를 쿠키 혹은 localStorage 등으로 관리하면서  
   매 요청에 담아서 서버에 전달하여 인증 및 인가 과정을 거친다.  
   왜냐하면 우리는 보통 http 프로토콜을 사용하고, http는 stateless이기 때문에,  
   내 상태를 저장하지 않고 내가 요청마다 내가 누군지 알려줘야 하기 때문이다.

3. 서버 입장에서  
   모든 요청에 인증 작업을 수행한다.  
   요청받은 내용에 담겨온 인증 및 인가정보가 정말로 올바른 정보인지 확인과정을 거친다.  
   매번 토큰등을 확인하여 올바른 사용자인지(인증),  
   그 사용자가 지금 요청한 행동에 권한이 있는지(인가)를 매 요청마다 확인한다.

### 백엔드에서의 권한 관리

백엔드에서 권한 관리를 위해 일반적으로 RBAC, ABAC라는 접근제어 메커니즘을 사용한다.

- RBAC(Role-Based Access Control)  
  어떤 작업이나 파일에 대한 접근 권한을 역할에 따라 결정한다.  
  역할이란 보통 같은 틍성을 공유하는 사용자 그룹을 의미한다.  
  부서, 위치, 담당업무 등을 기준으로 사용자 그룹을 만들 수 있고,  
  각 그룹마다 허용된 권한을 다르게 설정할 수 있다.

- ABAC(Attribute-Based Access Control)  
  사용자의 리소스 속성 혹은 환경에 따라 접근 권한을 결정한다.  
  현재 접속한 네트워크에 따라, 혹은 언제 만들어진 파일에 접근하는지에 따라  
  권한을 줄 것인지 거부할 것인지 결정할 수 있다.

위에서 짧게 언급한것처럼 백엔드 입장에서는 매 요청에 인증 + 인가 처리를 해줘야 한다.  
Spring Web MVC를 사용한다면, Controller에 요청이 전달되기 전에  
HandlerInterceptor로 우리가 원하는 코드를 먼저 실행할 수 있다.  
혹은 Spring Security를 사용하면 SecurityFilterChain을 통해서도 구현 가능하다.

## Cookie vs LocalStorage

일단 둘의 공통점은 웹 개발자가 나중에 다시 사용할 수 있도록  
브라우저에 데이터를 저장하는 메커니즘이라는 점이다.

### Cookie

쿠키는 사용자 브라우저에 저장하는 작은 문자열 파일이다. 쿠키는 오직 문자열 만 저장가능하다.  
일반적으로 크기는 4KB 정도 용량으로 제한된다.  
쿠키에는 Session Cookie와 Persistence Cookie가 있다.

Session Cookie는 만료일이 없고, 해당 브라우저 혹은 탭이 열려있는 동안 유지된다.  
주로 은행같은 곳에서 많이 사용한다.

Persistence Cookie는 만료일이 있다. 만료일까지 유저의 디스크에 저장되고, 이후에 삭제된다.  
주로 사용자의 방문 경험을 커스텀하는데 사용한다.

### LocalStorage

사용자의 브라우저에 Key-Value 쌍을 저장할 수 있는 브라우저 저장소.  
일반적으로 쿠키보다 더 큰 용량을 가진다.(약 5 ~ 10MB)  
문자열 뿐만 아니라, Json같은 복잡한 데이터 유형을 저장할 수 있다.  
로컬 저장소는 자동으로 삭제되지 않으며, 사용자가 브라우저를 닫거나 웹사이트를 떠나도 유지된다.

## Interceptor vs Filter

일단 둘 다 웹 어플리케이션에서 요청과 응답을 가로채서 무언가 처리하는 용도로 사용된다.  
하지만 아키텍쳐상 서로 다른 수준에서 동작한다.

### Filter

Jakarta 에서 지원하는 표준 기능이다.  
디스패처 서블릿(가장 먼저 HTTP 요청을 받아 적절한 컨트롤러에 분배해주는 서블릿)이 요청을 받기 전/후로  
해당 요청에 대한 부가적인 처리를 할 수 있게 해주는 기능이다.  
즉 스프링 컨텍스트 밖에서 처리가 되는 기능이다.

모든 HTTP 요청에 대해 실행되므로, 공통적인 보안 처리에 많이 사용된다.

### Interceptor

인터셉터는 Spring에서 제공하는 기능으로, 디스패처 서블릿이 컨트롤러를 호출하기 전/후로  
요청에 부가적인 처리를 할 수 있는 기능이다. 필터와 다르게 스프링 컨텍스트 안에서 처리된다.

HTTP 요청이 처리되는 순서를 생각하면 아래와 같은 순서로 처리될 것이다.

- HTTP -> Filter -> Dispatcher Servlet -> Interceptor -> Controller

인터셉터는 개별 API에 대한 보안처리 혹은 호출 로깅등에 사용된다.

## 암호화(Encryption)

암호화란 평문(원본 값)을 다른 사람이 알아보기 어렵게 변환하는 작업을 의미한다.  
반대로 암호화 된 값을 다시 평문으로 되돌리는 과정을 '복호화'라고 한다.  
일반적으로는 암호화, 복호화 과정이 양방향으로 가능하나,  
평문을 다시 복호화 할 수 없는 암호화도 있다.(단방향 암호화)

- 일반적 암호화와 복호화 : 평문 ↔ 암호문
- 단방향 암호화 : 평문 → 암호문 (비가역적)

패스워드를 저장할 때는 일반적으로 단방향 암호화된 형태로 저장한다.  
왜냐하면 혹여나 유출 되었을 때 암호화된 정보를 통해서 평문이 직접적으로 드러나지 않도록하기 위함이다.

실제 로그인을 하여 인증하는 과정에서는 사용자가 입력한 평문 비밀번호를 해당 인증에서 사용하는  
암호화 알고리즘으로 변환하고, 변환된 암호문을 DB에 저장된 정보와 매핑시켜 일치하는지 여부를 확인한다.

### 해시 알고리즘

일반적으로 그냥 암호화 라고 하면 양방향 암호화를 하는 것을 의미하고,  
단방향 암호화를 위해서는 암호학적 `해시 알고리즘`을 사용한다.

암호학적 해시 알고리즘은 아래의 성질을 가짐

1. 역상 저항성
   해시값(암호문)에서 원래 값(평문)을 찾을 수 없어야 한다.  
   즉 어떤 해시값이 주어질 때 그 해시값을 생성하는 평문을 계산하기 어려워야 한다는 개념이다.

2. 제2 역상 저항성  
   어떤 평문과 같은 해시값을 가지는 다른 평문을 찾기 어려워야 한다.

3. 충돌 저항성
   동일한 해시 값으로 변환되는 두 개의 값을 찾을 수 없어야 한다.  
   제2 역상 저항성과 비슷해 보이지만, 의미에 약간 차이가 있다.  
   충돌 저항성은 해시값을 알든 모르든, 같은 해시를 생성하는 평문 찾기에 대한 개념이고,  
   역상 저항성은 해시값을 알고있는 경우에 평문을 찾을 때 해당하는 개념이다.

사용자의 패스워드를 단방향 암호화를 하기 위해 비교적 최신 알고리즘인 Argon2, Balloon 등을 사용 권고.  
Spring Security에서 Argon2을 지원한다. Balloon은 아직 지원하지 않음.

## Salt

비밀번호를 해시 함수를 사용하여 암호화 하였다고 해도,  
이미 잘 알려진 해시값의 평문을 저장한 DB에서 검색을 통해 유추할 수 있다.  
이런 DB를 레인보우 테이블이라고 부르기도 한다.

또한 같은 비밀번호는 같은 해시값을 가지게 되기 때문에  
비밀번호 유출 시 연쇄적으로 피해가 불어날 수 있다.

이를 막기위해서, 쉽게 평문을 유추할 수 없도록 비밀번호를 암호화 할 때  
뒤에 임의의 문자열을 붙여서 암호화 하는 방법을 사용하는데,  
비밀번호 뒤에 붙이는 임의의 문자열을 salt라고 한다.
음식에 소금치는데 비유하여 이런 이름이 붙여졌다고 한다.

예를 들어 비밀번호가 qwer1234 이고 salt를 c38cnj19vnkscd9q3 라고 예를 들면  
해시함수에 qwer1234c38cnj19vnkscd9q3 으로 암호화를 시켜 저장하는 것이다.  
salt를 사용하면 해시값이 레인보우 테이블에 있을 확률이 아주아주 작아진다.  
또한 salt또한 임의의 문자열이기 때문에 무차별 대입으로 평문을 알아내기도 더욱 어려워진다.  
그리고 사용자 마다 고유한 salt를 사용하면 같은 비밀번호를 사용하더라도  
다른 해시값을 가지기 때문에, 비밀번호가 유출된다고 해도 피해를 줄일 수 있다.
