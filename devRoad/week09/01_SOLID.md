# SOLID

## 개요

SOLID란 객체 지향 설계 원칙이다.  
5가지 설계원칙을 앞 글자를 따서 쉽게 기억할 수 있도록 만들어 놓은 단어이다.  
보다 유지보수가 편하고, 나중에 추가적인 확장이 편한 소프트웨어를 만들기 위해서  
해당 원칙을 잘 지키도록 해야한다.

이를 토대로 어떻게 설계를 해야겠다 라는 패턴이 Hexagonal Architecture이다.

## SRP (Single Responsibility Principle)

한국어로 표현하면 단일 책임 원칙이다. 응집도에 관련된 설계 원칙이다.

한 문장으로 간결하게 설명하면 아래와 같다

> 어떤 클래스를 변경하는 이유는 오직 하나뿐 이어야 한다.

클래스를 변경한 다는 것은 그 클래스의 역할, 책임이 변한다는 의미이다.  
그리고 클래스의 책임이란 클래스가 수행하는 기능이다.

즉 어떤 클래스의 변경 이유가 하나 뿐 이라는 것은 그 클래스가 가지는 책임이 하나라는 의미이다.  
하나의 책임이 한 클래스에 있으면 우선 관리하기가 쉽고 테스트 코드 작성도 간결해진다.  
그리고 이후에 재사용에도 용이하고, 해당 책임에 변경점이 생겼을 때  
여러 부분을 연쇄적으로 수정해야하는 상황에서 자유로울 수 있다.

보통 application 레이어에서 실제 도메인 관련 변화는 도메인 모델에게 책임을 분산하고,  
DB와 관련된 부분은 Repository의 형태로 책임을 분리하여 SRP을 지키도록 설계한다.

SRP는 SOLID의 다른 원칙들을 위한 기초가 되므로 멀어지지 않도록 유의하면서 프로그래밍 해야한다.

## OCP (Open-Closed Principle)

한국어로 표현하면 개방-폐쇄 원칙이다.

소프트웨어를 이루는 어떠한 구성요소(클래스, 객체, 함수 등)가 확장에는 열려있어야 하고, 수정에 대해서는 닫혀있어야 한다.  
확장에는 열려있다는 말은 해당 요소가 맡고있던 기능이 변경되거나 추가적인 기능을 요구로 할 때  
새로운 동작을 추가 할 수 있다는 의미이다.  
수정에는 닫혀있다는 의미는 해당 구성요소에 대한 변경이 주변의 다른 구성요소들에게 영향을 주면 안되고,  
반대로 주변의 변경사항에 의해 어떤 구성요소가 바뀌면 안된다는 의미이다.

대게는 변경 혹은 확장이 필요한 부분을 구분하고,  
변하지 않을 부분을 인터페이스로 정의하고,  
정의한 인터페이스에 의존하도록 코드를 작성하는 형태로 적용할 수 있다.

> 엉클 밥에 따르면 OCP는 객체지향 설계의 심장
> 본질은 다형성에 대한 이야기이지만, OCP라는 개념을 맘속에 담아두자

## LSP (Liskov substitution principle)

리스코프 치환 원칙은 아마 SOLID 원칙 중 가장 이해하기 난해한 원칙일 것이다.  
이름에서 유추할 수 있기도 하듯 바바라 리스코프(Barbara Liskov)가 1988년 제시한 파생(상속) 에 관한 원칙을 기반으로 한다.

> 타입 S의 객체 object_s와 타입 T의 객체 object_t가 있다.  
> T로 정의된 프로그램 P에서, object_t를 object_s로 치환했을 경우에  
> P의 행위가 변하지 않는다면 S는 T의 서브 타입이다.

위의 내용이 바바라 리스코프가 제시한 내용인데, 이를 조금 더 와닿고 쉽게 표현하자면,,

> 서브타입(자식타입)은 그것의 기반타입(부모타입)으로 치환가능해야 한다.

호출하는 프로그램 입장에서는 자식타입이든 부모타입이든 신경쓰지 않고 기능을 호출 할 수 있어야한다.  
그러기 위해서는 자식타입에서 부모타입에서 가능한 기능을 모두 보장해야 한다.

리스코프 치환원칙을 지킴으로써 자식타입을 좀 더 유연한 활용이 가능하여  
좀 더 변화 혹은 확장에 쉽게 수정가능한 코드를 만들 수 있다.

## ISP (Interface segregation principle)

문자 그대로 인터페이스 분리 원칙이다.  
커다란 인터페이스를 여러 개의 작은 인터페이스로 나눌것을 권장하는 원칙이다.  
각각의 작은 인터페이스는 특정한 동작 집합에 대해 집중하여 작성되는것을 권장한다.  
작은 단위로 나누어 놓으면 유지보수 및 사용 측면에서 읽기도 편하고 재 사용하기 쉬워진다.

UseCase(기능)만큼의 인터페이스를 생성하고, 하나의 서비스 클래스에서  
해당 서비스가 가지는 UseCase만큼 구현하는 방식으로 구현이 가능하다.

## DIP (Dependency inversion principle)

마지막으로 의존관계 역전 원칙이다.  
의존관계 역전 원칙은 두가지 부분으로 나누어 설명 할 수 있다.

    1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
    2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

먼저 '의존'이라는 단어의 정의부터 다시 상기해보자.  
어떤 클래스가 내부에서 클래스B 를 사용하고 있다고 가정하자, 즉 A를 실행하는데 B가 필요하다.  
이때 `클래스 A는 클래스B 에 의존적이다` 라고 한다.

일단 상위수준의 모듈은 비즈니스 로직을 다루는 부분(서비스 레이어)를 의미하고,
하위 수준의 모듈은 상위 수준의 모듈에서 호출하는 기술적인 부분(DB와 같은)을 의미한다.
보통 상위 수준의 모듈이 하위 수준의 모듈을 사용한다 라는 개념이 자연스럽기는 하다.(상위 모듈이 하위 모듈에 의존한다.)  
그러나 하위 수준의 모듈, 즉 기술적인 부분은 빈번하게 변경 혹은 기능 추가가 이루어 질 수 있으므로  
의존관계를 역전 시켜야 한다.

그렇다고 곧바로 하위 모듈이 상위 모듈에 의존하라는 것은 아니고, 둘다 추상화 모듈에 의존해야 한다.  
그리고 그 추상화는 구체적인 구현에 의존하지 않고, 구현이 추상화에 의존해야 한다.  
추상화란 핵심개념 혹은 기능을 간추려 낸 것을 의미한다.  
여러곳에서 필요한 핵심 기능을 불필요한 구현을 제외한 핵심 정보면 나타내는 개념이 추상화 이다.  
자바에는 보통 interface 형태로 많이 구현하며, 어떠한 인터페이스를 상속받아 실제 구체적인 구현 클래스를 작성하는것이 일반적이다.
